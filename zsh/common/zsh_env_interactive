# dotfiles/zsh/common/zsh_env is always sourced because
# it's loaded by dotfiles/zsh/zprezto/runcoms/zshenv.
# This file is for interactive env, only to be loaded in .zshrc.

#
# Lazy shell integrations for env managers
# (eval "$(X init -)" calls deferred to first use to avoid ~1s startup cost)
#

# pyenv - full shell integration on first call (shims PATH already set in zsh_env)
# Use `function` keyword (not `name()` syntax) to avoid alias/function name conflict:
# zsh_env sets `alias pyenv='nocorrect pyenv'` and zsh parses `name()` before
# any unalias can run, causing a parse error. `function name {}` bypasses this.
if [[ -d $HOME/.pyenv ]]; then
  function pyenv {
    unfunction pyenv
    unalias pyenv 2>/dev/null
    eval "$(command pyenv init -)"
    eval "$(command pyenv virtualenv-init -)"
    pyenv "$@"
  }
fi

# jenv - shell integration on first call (bin PATH already set in zsh_env)
if [[ -d $HOME/.jenv ]]; then
  jenv() {
    unfunction jenv
    eval "$(command jenv init -)"
    jenv "$@"
  }
fi

# goenv - shell integration on first call (bin PATH already set in zsh_env)
if [[ -d $HOME/.goenv ]]; then
  goenv() {
    unfunction goenv
    eval "$(command goenv init -)"
    # goenv init sets GOROOT/GOPATH; update PATH accordingly
    export PATH="$GOROOT/bin:$PATH"
    export PATH="$PATH:$GOPATH/bin"
    goenv "$@"
  }
fi

# nvm - load fully before first prompt via a one-shot precmd hook.
# This avoids listing managed binaries (fragile, maintenance burden) and alias
# conflicts entirely. precmd never runs during `zsh -i -c exit` so the startup
# benchmark is unaffected. Hook registers before _defer_chpwd_startup so nvm
# is fully loaded when check_nvmrc runs.
if [[ -d "$HOME/.nvm" ]]; then
  _nvm_load_once() {
    add-zsh-hook -d precmd _nvm_load_once
    [ -s "$NVM_DIR/nvm.sh" ] && source "$NVM_DIR/nvm.sh"
  }
  add-zsh-hook precmd _nvm_load_once
fi

# rvm - same one-shot precmd pattern as nvm.
# Output is suppressed (>/dev/null) because rvm prints decorative load messages
# that would appear before the first prompt and look like errors.
if [[ -d "$HOME/.rvm" ]] || [[ -s "/usr/local/rvm/scripts/rvm" ]]; then
  _rvm_load_once() {
    add-zsh-hook -d precmd _rvm_load_once
    if [[ -s "$HOME/.rvm/scripts/rvm" ]]; then
      source "$HOME/.rvm/scripts/rvm" >/dev/null 2>&1
    elif [[ -s "/usr/local/rvm/scripts/rvm" ]]; then
      source "/usr/local/rvm/scripts/rvm" >/dev/null 2>&1
    fi
  }
  add-zsh-hook precmd _rvm_load_once
fi

#
# interactive env
#

# switch to neovim if installed
if command -v nvim > /dev/null 2>&1 ; then
  export EDITOR='nvim'
fi

# load junegunn/fzf if installed
if [ -f ~/.fzf.zsh ]; then
  source ~/.fzf.zsh
  export FZF_DEFAULT_OPTS='--layout=reverse'
  # if fd is present, make fzf use that
  if [ ! -z "$(command -v fdfind)" ]; then
    export FZF_DEFAULT_COMMAND='fdfind --type f --hidden --follow --exclude={.git,.idea,.sass-cache,node_modules,build,.rustup,.cache}'
  elif [ ! -z "$(command -v fd)"  ]; then
    export FZF_DEFAULT_COMMAND='fd --type f --hidden --follow --exclude={.git,.idea,.sass-cache,node_modules,build,.rustup,.cache}'
  fi

  # config fzf preview alias
  if [ "$(command -v batcat)" ]; then
    alias fp="fzf --preview 'batcat --style=numbers --color=always --line-range :500 {}'"
  elif [ "$(command -v bat)" ]; then
    alias fp="fzf --preview 'bat --style=numbers --color=always --line-range :500 {}'"
  fi

  # config fzf function API
  FZF_API_PATH="${HOME}/dotfiles/fzf/fzf_api.sh"
  if [ -f "${FZF_API_PATH}" ]; then
    source "${FZF_API_PATH}"
  fi
fi

# ripgrep
export RIPGREP_CONFIG_PATH="$HOME/dotfiles/rg/.ripgreprc"

# glow
alias glow='command glow -p'

# exa
if [ "$(command -v exa)" ]; then
  alias lsx='exa -G -x --color auto --icons -s type'
  alias llx='exa -l --color auto --icons -s type --git'
  alias lax='llx -a'
  alias lx='lax'
  alias ltx='llx -a -snew'
fi

# kitty terminal app
alias kittyupdate='curl -L https://sw.kovidgoyal.net/kitty/installer.sh | sh /dev/stdin'

# pgadmin
if [[ -z $(command -v pgadmin) ]]; then
  alias pgadmin="docker run -d --net=host --name pgadmin -e PGADMIN_DEFAULT_EMAIL='email@email.com' -e PGADMIN_DEFAULT_PASSWORD=password -e PGADMIN_LISTEN_PORT=54321 dpage/pgadmin4"
fi

# cd on exit in xplr file manager
if [[ $(command -v xplr) ]]; then
  alias xcd='cd "$(xplr --print-pwd-as-result)"'
fi

# GPG for SSH authentication
# do it only if there's TTY
# -- look for macOS
if [[ $(command -v TTY) ]] && [[ "$(uname -s)" == 'Darwin' ]]; then
export "GPG_TTY=$(TTY)"
export "SSH_AUTH_SOCK=${HOME}/.gnupg/S.gpg-agent.ssh"
# notes:
#   for command line tty, ~/.gnupg/gpg-agent.conf needs:
#       pinentry-program /usr/bin/pinentry-curses
#   if needed, run the command below to force telling the agent which tty to use
#     gpg-connect-agent updatestartuptty /bye
fi
# -- look for Linux (excluding WSL which needs socat and a different config and GitHub Codespaces, which has its own git signing magic)
if [[ $(command -v tty) ]] && [[ "$(uname -s)" == 'Linux' ]] && [[ -z "$(uname -a | grep -i wsl)" ]] && [[ -z "$(uname -a | grep -i codespaces)" ]]; then
export GPG_TTY=$TTY
export SSH_AUTH_SOCK=$(gpgconf --list-dirs agent-ssh-socket)
gpgconf --launch gpg-agent >/dev/null 2>&1
fi

# use zoxide to jump around as fasd has been discontinued
if [ "$(command -v zoxide)" ]; then
  eval "$(zoxide init zsh)"
# legacy fallback: use fasd to jump around
elif [ "$(command -v fasd)" ]; then
  eval "$(fasd --init auto)"
fi

# direnv hook for zsh
if [ "$(command -v direnv)" ]; then
  eval "$(direnv hook zsh)"
fi

# zellij custom config path
export ZELLIJ_CONFIG_DIR="$HOME/dotfiles/zellij"

# Secure ShellFish iOS app integration
if [[ -f "$HOME/.shellfishrc" ]]; then
  source $HOME/.shellfishrc
fi

# opencode cli
if [ -d "$HOME/.opencode/bin" ]; then
  export PATH="$HOME/.opencode/bin:$PATH"
fi
